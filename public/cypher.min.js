"use strict";
var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cypher = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const node_crypto_1 = __importDefault(require("node:crypto"));
const CYPHER_APP_VERSION = "v1";
const ENCRYPTION_ALGORITHM = "aes-256-cbc";
class Cypher {
  constructor({ appId, appSecret, JWT_SECRET }) {
    this.JWT_SECRET = JWT_SECRET;
    this.formattedAppId = appId;
    this.formattedAppSecret = appSecret;
    const appIdActualValue = jsonwebtoken_1.default.verify(
      appId.split(":")[2],
      JWT_SECRET
    );
    const appSecretActualValue = jsonwebtoken_1.default.verify(
      appSecret.split(":")[2],
      JWT_SECRET
    );
    const appIdRegex = /^dvApp:v1:[a-zA-Z0-9._-]+$/i;
    const appSecretRegex = /^pss:v1:[a-zA-Z0-9._-]+$/i;
    if (!appIdRegex.test(appId) || !appSecretRegex.test(appSecret)) {
      throw new Error("Invalid Credentials Provided");
    }
    this.appId = Buffer.from(appIdActualValue, "hex");
    this.appSecret = Buffer.from(appSecretActualValue, "hex");
  }
  encrypt(plainText) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const cipher = node_crypto_1.default.createCipheriv(
          ENCRYPTION_ALGORITHM,
          this.appSecret,
          this.appId
        );
        let encrypted = cipher.update(plainText, "utf-8", "hex");
        encrypted += cipher.final("hex");
        const encryptedPayload = `dvApp:${CYPHER_APP_VERSION}:${encrypted}`;
        return encryptedPayload;
      } catch (err) {
        throw new Error("Encryption failed");
      }
    });
  }
  decrypt(payload) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const encrypted = payload.split(":")[2];
        const decipher = node_crypto_1.default.createDecipheriv(
          ENCRYPTION_ALGORITHM,
          this.appSecret,
          this.appId
        );
        let decrypted = decipher.update(encrypted, "hex", "utf-8");
        decrypted += decipher.final("utf-8");
        return decrypted;
      } catch (err) {
        throw new Error("Decryption failed");
      }
    });
  }
}
exports.Cypher = Cypher;
